# 停止基于服务的线程
对于拥有多个线程的服务，比如线程池，这些线程池服务的生命周期往往比任务的生命
周期更长，如果应用程序需要退出，那么这个服务管理的线程也应该要退出。而对线程
的操作原则为：操作者必须为线程的拥有者，否则不应该对线程进行操作。

线程由Thread表示，线程的所有者为创建该线程的类。因此线程池是工作线程的
所有者，要中断这些线程，应该有线程池来进行处理。

服务应该提供生命周期方法来管理它所拥有的线程，这样应用程序就可以通过
服务来关闭线程了。比如ExecutorService提供的shutdown和shutdownNow
方法。对于持有线程的服务，如果服务的存在的时间大于创建线程方法的时间，
就应该提供生命周期的方法。

## 日志服务分析（基于标志位的关闭方法）
LoggerThread实现的日志服务，如果处理日志的速度慢于接收日志的速度，那么
就可能对客户端的调用造成阻塞；而且该线程也没办法关闭，导致JVM无法结束。

如果只是简单的关闭改线程，是十分简单的。因为take方法会响应线程，因此可以
通过调用LoggerThread的interrupt方法实现。但是这种退出机制是不完备的，
直接调用interrupt方法会导致日志队列的剩余日志未被处理的情形。完备的退出
机制是：停止接受新的日志，等待处理完队列中剩余日志时退出。

LoggerService实现了比较可靠的关闭机制。通过一个计数器能够检查到当前队列
剩余日志的数量，可以帮助消费线程在处理完剩余的日志后优雅退出。

## 关闭Executor（shutdown和shutdownNow方法）
ExecutorService提供了两个关闭方法：shutdown和shutdownNow。shutdown
方法正常关闭，不在接受新的任务，且等到任务队列中的剩余任务处理结束后退出。
shutdownNow是强行关闭，它会中断正在执行的任务，并返回未执行的任务列表。

简单的程序通常在main方法中创建ExecutorService，而更复杂的程序则将
ExecutorService封装在另一个更高级别的服务中，该服务提供自己的生命周期。

## 毒丸对象（基于毒丸对象的关闭）
另一种关闭生产者-消费者服务的方法就是使用毒丸对象（Poison pill)。毒丸对象
是指放在一个队列上的特殊对象，当等到这个对象时，立即停止。在FIFO类型队列中，
毒丸对象能够确保消费者在关闭之前完成队列中所有的工作。

也就是生成者提交了毒丸对象后，不再提交新的任务；而消费者也能保证毒丸对象
之前的任务都会被处理。

毒丸模式只适合用在生产者和消费者数量已知的情况下，当放入N个毒丸到队列中，
应当接收到N个毒丸对象后再停止。

## 执行一次的任务（执行完任务后自我关闭）
这种关闭模式是指每次执行都创建一个私有的ExecutorService，将要执行的任务提交
到Executor中后，利用shutdown和waitTermination的技巧关闭Executor，并
等待返回结果。

## shutdownNow的局限性
通过shutdownNow方法强制关闭Executor时，他会尝试取消正在执行的任务，并返回所有
已经提交但未执行的任务。但是我们无法通过常规的方法找出哪些任务已经开始但尚未结束，
也没有办法检查任务的状态。

但是可以通过重写ExecutorService的实现，从而达到记录被异常关闭的任务的效果。
