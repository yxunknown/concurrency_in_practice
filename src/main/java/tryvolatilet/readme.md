# java 内存模型
堆内存用来存储对象实例，是所有线程共享的运行时区域，存在可见性的问题。

局部变量、方法定义的参数不会在线程之间共享，没有可见性的问题。

线程之间共享的变量放在主内存中，而每一个线程都有一个私有的本地内存。
在线程的私有本地内存里，存储了该线程贡共享的变量副本。

# A,B线程的通信过程
1. 线程A把本地内存的共享变量更新后刷入到主存
2. 线程B在主存读取线程A更新的变量

线程更新变量遵循 load->modify->save的过程

# 原子性、可见性、有序性
## 原子性
操作能同时完成，不会被破坏和中断。在Java中，只有简单的读取
和复制操作才具有原子性。当多个原子语句复合在一起时，原子性会被
破坏。

## 可见性
可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。
被volatile修饰的变量，在被修改后会立即更新到主存区，所以对其他线程
是可见的。而普通变量在更新后，不会被立即写入到主存中，因此没办法
保证对其他现场的可见性，其他现场读取到的可能是来自该线程的私有本地
内存区的缓存值。

## 有序性
Java的内存模型允许编译器喝处理器对指令进行重新排序，这种排序不会
影响单线程的正确性，但是会对多线程程序的并发执行带来影响。可以通过
volatile、synchronized、Lock等技术保证指令的有序性。

# volatile
对于被volatile修饰的变量：
1. 任何线程该变量的修改都会立即更新到主存中，保证对其他线程的可见性
2. 禁止指令的重排序  

**重排序**是一种编译器或运行时为了优化程序性能而对指令进行重新排序执行
的一种手段。分为编译期重排序和运行期重排序。

volatile只保证该变量对其他线程的可见性以及指令的有序性，但不保证对该变量操作的原子性。

# volatile使用方法
synchronized能避免多个线程同时执行一段代码，不过也随之降低了
程序的性能。volatile则对性能的影响要小得多，但是volatile无法保证
操作的原子性。因此，是有volatile时，必须具备如下条件：
1. 对变量的写操作不依赖变量的当前值，也就是不能有自增或自减等操作
2. 该变量不包含在具有其他变量的不变式中

# volatile的使用场景
1. 作为状态标志  
比如用来控制线程的执行
2. 双重检查模式  
比如用于singleton的实现，  
```java
public class Singleton{
    private volatile static final Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (this) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    
    // 私有化构造器
    private Singleton() {}
}
```
 